{
  "architecture": "# Proxy Checker Service - Architecture\n\n## System Overview\n\nThe service uses Go 1.21+ with goroutines for 10k-25k concurrent proxy checking on a 12-thread server.\n\n### Concurrency Model\n- **Language:** Go with native goroutines + netpoll\n- **Threading:** GOMAXPROCS=12 (utilize all CPU threads)\n- **Goroutines:** 20,000+ lightweight (2-8KB stack each)\n- **I/O:** Non-blocking netpoll (epoll/kqueue)\n- **Memory:** ~300MB at 20k concurrency\n- **CPU:** 70-90% utilization at 20k concurrency\n\n### Process Architecture\n\nSingle-process design (preferred) with internal goroutine pool:\n```\n1 Process × 20,000 goroutines\nGOMAXPROCS=12 → 12 OS threads (P's)\nGoroutine scheduler distributes work across threads\n```\n\nAlternative multi-process (if needed):\n```\n4 Processes × 5,000 goroutines each = 20k total\nEach process: GOMAXPROCS=3 (3×4=12 threads)\n```\n\n### Component Flow\n\n```\n┌─────────────────────────────────────────────────────────┐\n│                   AGGREGATOR                            │\n│  - Fetch sources concurrently (goroutines)              │\n│  - Dedupe proxies                                       │\n│  - Runs every 60 seconds                                │\n└──────────────────┬──────────────────────────────────────┘\n                   │\n                   ▼\n┌─────────────────────────────────────────────────────────┐\n│                CHECKER ENGINE                           │\n│  - Spawn 20k goroutines (semaphore controlled)          │\n│  - HTTP transport with connection pooling               │\n│  - Batch processing (2k proxies per batch)              │\n│  - Adaptive concurrency (backpressure)                  │\n└──────────────────┬──────────────────────────────────────┘\n                   │\n                   ▼\n┌─────────────────────────────────────────────────────────┐\n│            ATOMIC SNAPSHOT (atomic.Value)               │\n│  - Lock-free reads for API                              │\n│  - Atomic pointer swap on update                        │\n│  - Round-robin proxy selection                          │\n└──────────────────┬──────────────────────────────────────┘\n                   │\n                   ├──────────────────┐\n                   ▼                  ▼\n           ┌──────────────┐   ┌──────────────┐\n           │  REST API    │   │  STORAGE     │\n           │  (Gin)       │   │  (File/DB)   │\n           │  - /get      │   │  - Persist   │\n           │  - /stat     │   │  - Load      │\n           │  - /health   │   └──────────────┘\n           │  - /metrics  │\n           └──────────────┘\n```\n\n### File Descriptor Budget\n\n20,000 concurrent checks × 2 FDs = 40,000 FDs\n+ 1,000 for API/logs = 41,000 total\n**Recommended ulimit -n 65535**\n\n### Memory Projections\n\n| Concurrency | Goroutines | Buffers | Total |\n|-------------|------------|---------|-------|\n| 10k         | 40MB       | 80MB    | 175MB |\n| 20k         | 80MB       | 160MB   | 300MB |\n| 25k         | 100MB      | 200MB   | 360MB |\n\n### TCP Tuning Requirements\n\n```bash\nnet.ipv4.ip_local_port_range = 10000 65535\nnet.ipv4.tcp_max_syn_backlog = 8192\nnet.ipv4.tcp_tw_reuse = 1\nnet.core.somaxconn = 8192\n```\n\n### Why Go vs Alternatives\n\n**Go (chosen):**\n- M:N threading optimal for this workload\n- Built-in netpoll for efficient I/O\n- Simple concurrency model\n- Fast compilation and deployment\n\n**Node.js:**\n- Single-threaded, needs cluster mode\n- Higher memory per process\n- Less efficient for CPU-bound work\n\n**Rust + tokio:**\n- Comparable performance\n- More complex error handling\n- Longer development time\n\nSee ARCHITECTURE.md for complete details.",
  
  "plan": "# Implementation Plan\n\n## Timeline: 8 Days\n\n### Phase 1: Infrastructure (Days 1-2)\n- Config management (hot reload)\n- Aggregator (concurrent source fetching)\n- Storage layer (File/SQLite/Redis)\n- Snapshot manager (atomic.Value)\n\n### Phase 2: Checker (Days 3-4)\n- HTTP transport tuning (20k connections)\n- Semaphore concurrency control\n- Batch processing\n- Retry logic with backoff\n- Adaptive concurrency\n- Prometheus metrics\n\n### Phase 3: API (Day 5)\n- Gin HTTP server\n- Endpoints: /get-proxy, /stat, /health, /metrics, /reload\n- Authentication (API key)\n- Rate limiting (per-key, per-IP)\n- Graceful shutdown\n\n### Phase 4: Testing (Days 6-7)\n- Unit tests (>80% coverage)\n- Integration tests (full cycle)\n- Performance benchmarks (10k, 20k, 25k)\n- Load testing (wrk/vegeta)\n\n### Phase 5: Deployment (Day 8)\n- Dockerfile (multi-stage)\n- docker-compose.yml\n- systemd service\n- Prometheus/Grafana dashboards\n- Documentation\n\n## Team: 1 Senior Go Developer\n\nSee IMPLEMENTATION_PLAN.md for milestones.",
  
  "config_schema": {
    "aggregator": {
      "interval_seconds": 60,
      "sources": [
        {
          "url": "https://example.com/proxies.txt",
          "type": "txt",
          "enabled": true
        }
      ],
      "user_agent": "Mozilla/5.0 (compatible; ProxyChecker/1.0)"
    },
    "checker": {
      "timeout_ms": 15000,
      "concurrency_total": 20000,
      "batch_size": 2000,
      "retries": 1,
      "test_url": "https://www.google.com/generate_204",
      "mode": "full-http",
      "enable_adaptive_concurrency": true,
      "max_fd_usage_percent": 80,
      "max_cpu_usage_percent": 95
    },
    "api": {
      "addr": ":8080",
      "api_key_env": "PROXY_API_KEY",
      "rate_limit_per_minute": 1200,
      "rate_limit_per_ip": 100,
      "enable_api_key_auth": true,
      "enable_ip_rate_limit": true
    },
    "storage": {
      "type": "file",
      "path": "/data/proxies.json",
      "persist_interval_seconds": 300
    },
    "metrics": {
      "enabled": true,
      "endpoint": "/metrics",
      "namespace": "proxychecker"
    },
    "logging": {
      "level": "info",
      "format": "json"
    }
  },
  
  "dockerfile": "FROM golang:1.21-alpine AS builder\nRUN apk add --no-cache git gcc musl-dev sqlite-dev\nWORKDIR /build\nCOPY go.mod go.sum ./\nRUN go mod download\nCOPY . .\nRUN CGO_ENABLED=1 GOOS=linux go build -a -installsuffix cgo \\\n    -ldflags=\"-s -w -extldflags '-static'\" \\\n    -o proxy-checker ./cmd/main.go\n\nFROM alpine:latest\nRUN apk --no-cache add ca-certificates tzdata\nRUN addgroup -g 1000 proxychecker && \\\n    adduser -D -u 1000 -G proxychecker proxychecker\nWORKDIR /app\nCOPY --from=builder /build/proxy-checker .\nCOPY --from=builder /build/config.example.json ./config.json\nRUN mkdir -p /data && chown -R proxychecker:proxychecker /data /app\nUSER proxychecker\nEXPOSE 8080\nHEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \\\n    CMD wget --no-verbose --tries=1 --spider http://localhost:8080/health || exit 1\nCMD [\"./proxy-checker\"]",
  
  "systemd_unit": "[Unit]\nDescription=Proxy Checker Service\nDocumentation=https://github.com/your-org/proxy-checker-api\nAfter=network-online.target\nWants=network-online.target\n\n[Service]\nType=simple\nUser=proxychecker\nGroup=proxychecker\nWorkingDirectory=/opt/proxy-checker\nEnvironmentFile=/etc/proxy-checker/env\nNoNewPrivileges=true\nPrivateTmp=true\nProtectSystem=strict\nProtectHome=true\nReadWritePaths=/var/lib/proxy-checker\nLimitNOFILE=65535\nLimitNPROC=512\nExecStart=/opt/proxy-checker/proxy-checker\nExecReload=/bin/kill -HUP $MAINPID\nRestart=on-failure\nRestartSec=10s\nStartLimitInterval=300\nStartLimitBurst=5\nStandardOutput=journal\nStandardError=journal\nSyslogIdentifier=proxy-checker\nWatchdogSec=30s\n\n[Install]\nWantedBy=multi-user.target",
  
  "performance_plan": "# Performance Testing Plan\n\n## Environment Setup\n\n```bash\n# File descriptors\nulimit -n 65535\n\n# TCP tuning\nsudo sysctl -w net.ipv4.ip_local_port_range=\"10000 65535\"\nsudo sysctl -w net.ipv4.tcp_max_syn_backlog=8192\nsudo sysctl -w net.ipv4.tcp_tw_reuse=1\nsudo sysctl -w net.core.somaxconn=8192\n```\n\n## Test Scenarios\n\n### 1. Checker Performance\n\n**Test 1.1: 10k Concurrency**\n- Config: concurrency_total=10000\n- Expected: 30-60s completion, <200MB memory\n\n**Test 1.2: 20k Concurrency (Target)**\n- Config: concurrency_total=20000\n- Expected: 45-90s completion, <350MB memory\n\n**Test 1.3: 25k Concurrency (Maximum)**\n- Config: concurrency_total=25000\n- Expected: 60-120s completion, <400MB memory\n\n**Test 1.4: Stress Test**\n- Run continuous cycles for 1 hour\n- Monitor: memory, goroutines, FDs\n- Expected: No leaks, stable performance\n\n### 2. API Performance\n\n**Test 2.1: Throughput**\n```bash\nwrk -t12 -c400 -d60s --latency \\\n  -H \"X-Api-Key: key\" \\\n  http://localhost:8080/get-proxy\n```\nExpected: >10k RPS, p99 < 50ms\n\n**Test 2.2: Rate Limiting**\n```bash\nvegeta attack -rate=1500/1m -duration=60s\n```\nExpected: First 1200/min pass, rest 429\n\n### 3. Tools\n\n- **wrk** - HTTP load testing\n- **vegeta** - Constant-rate testing\n- **pprof** - CPU/memory profiling\n- **prometheus** - Metrics collection\n\n### 4. Monitoring During Tests\n\n```bash\n# Memory\nps aux | grep proxy-checker\n\n# File descriptors\nlsof -p $(pgrep proxy-checker) | wc -l\n\n# Goroutines\ncurl http://localhost:8080/metrics | grep go_goroutines\n```\n\n## Performance Targets\n\n| Metric | Target | Critical |\n|--------|--------|----------|\n| Concurrent Checks | 20k | 10k |\n| Check Cycle | <90s | <180s |\n| Memory | <350MB | <500MB |\n| CPU | 70-90% | <95% |\n| API p99 | <50ms | <200ms |\n\nSee PERFORMANCE_TESTING.md for complete plan.",
  
  "tests": "# Test Suite\n\n## Structure\n\n```\ntests/\n├── unit/              # Unit tests (>80% coverage)\n│   ├── aggregator_test.go\n│   ├── checker_test.go\n│   ├── snapshot_test.go\n│   └── storage_test.go\n├── integration/       # Integration tests\n│   ├── api_test.go\n│   └── full_cycle_test.go\n└── e2e/\n    └── smoke_test.sh  # End-to-end tests\n```\n\n## Running Tests\n\n```bash\n# All tests\ngo test ./... -v -race -cover\n\n# Unit only\ngo test ./internal/... -v -short\n\n# Integration\ngo test ./tests/integration/... -v\n\n# Benchmarks\ngo test ./... -bench=. -benchmem\n\n# Coverage\ngo test ./... -coverprofile=coverage.out\ngo tool cover -html=coverage.out\n```\n\n## Example Unit Test\n\n```go\nfunc TestChecker_Concurrency(t *testing.T) {\n    cfg := config.CheckerConfig{\n        TimeoutMs:        5000,\n        ConcurrencyTotal: 100,\n        TestURL:          \"http://example.com\",\n        Mode:             \"connect-only\",\n    }\n    chk := checker.NewChecker(cfg, metrics.NewCollector(\"test\"))\n    \n    proxies := make([]string, 500)\n    for i := range proxies {\n        proxies[i] = \"192.168.1.1:8080\"\n    }\n    \n    start := time.Now()\n    results := chk.CheckProxies(context.Background(), proxies)\n    duration := time.Since(start)\n    \n    assert.Len(t, results, 500)\n    assert.Less(t, duration, 30*time.Second)\n}\n```\n\n## Smoke Test\n\n```bash\n#!/bin/bash\n# tests/e2e/smoke_test.sh\n\nAPI_KEY=\"changeme123\"\nBASE=\"http://localhost:8080\"\n\n# Test 1: Health\ncurl -f $BASE/health || exit 1\n\n# Test 2: Get proxy\nPROXY=$(curl -s -H \"X-Api-Key: $API_KEY\" $BASE/get-proxy)\n[[ $PROXY =~ : ]] || exit 1\n\n# Test 3: Stats\nSTATS=$(curl -s -H \"X-Api-Key: $API_KEY\" $BASE/stat)\necho $STATS | jq -e '.total_scraped' || exit 1\n\necho \"All tests passed!\"\n```\n\n## CI/CD\n\n```yaml\n# .github/workflows/test.yml\nname: Tests\non: [push, pull_request]\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - uses: actions/setup-go@v4\n      with:\n        go-version: '1.21'\n    - run: go test ./... -v -race -coverprofile=coverage.out\n    - run: bash tests/e2e/smoke_test.sh\n```\n\nSee TESTS.md for complete test documentation.",
  
  "ops_checklist": "# Operations Checklist\n\n## Pre-Deployment\n\n### System Tuning\n\n```bash\n# File descriptors\nulimit -n 65535\necho \"* soft nofile 65535\" | sudo tee -a /etc/security/limits.conf\necho \"* hard nofile 65535\" | sudo tee -a /etc/security/limits.conf\n\n# TCP tuning\nsudo tee /etc/sysctl.d/99-proxy-checker.conf <<EOF\nnet.ipv4.ip_local_port_range = 10000 65535\nnet.ipv4.tcp_max_syn_backlog = 8192\nnet.ipv4.tcp_fastopen = 3\nnet.ipv4.tcp_tw_reuse = 1\nnet.core.somaxconn = 8192\nnet.netfilter.nf_conntrack_max = 200000\nEOF\n\nsudo sysctl -p /etc/sysctl.d/99-proxy-checker.conf\n```\n\n### Installation\n\n```bash\n# Create user\nsudo useradd -r -s /bin/false proxychecker\n\n# Create directories\nsudo mkdir -p /opt/proxy-checker\nsudo mkdir -p /var/lib/proxy-checker\nsudo mkdir -p /etc/proxy-checker\n\n# Install binary\nsudo cp proxy-checker /opt/proxy-checker/\nsudo chmod +x /opt/proxy-checker/proxy-checker\n\n# Install config\nsudo cp config.json /etc/proxy-checker/\nsudo chmod 640 /etc/proxy-checker/config.json\n\n# Set ownership\nsudo chown -R proxychecker:proxychecker /opt/proxy-checker\nsudo chown -R proxychecker:proxychecker /var/lib/proxy-checker\n```\n\n### Systemd Setup\n\n```bash\n# Install service\nsudo cp proxy-checker.service /etc/systemd/system/\nsudo systemctl daemon-reload\nsudo systemctl enable proxy-checker\nsudo systemctl start proxy-checker\n\n# Verify\nsudo systemctl status proxy-checker\ncurl http://localhost:8080/health\n```\n\n## Monitoring\n\n### Key Metrics\n\n```promql\n# Alive proxies\nproxychecker_alive_proxies\n\n# Check rate\nrate(proxychecker_checks_total[5m])\n\n# Success rate\nrate(proxychecker_checks_success_total[5m]) / rate(proxychecker_checks_total[5m])\n\n# API latency p99\nhistogram_quantile(0.99, rate(proxychecker_api_request_duration_seconds_bucket[5m]))\n```\n\n### Alerts\n\n- No alive proxies (critical)\n- Low proxy count < 100 (warning)\n- High failure rate > 80% (warning)\n- API latency p99 > 500ms (warning)\n- Service down (critical)\n\n## Maintenance\n\n### Daily\n- Check logs for errors\n- Verify proxy count\n- Monitor memory/CPU\n\n### Weekly\n- Review metrics\n- Check disk space\n- Verify backups\n\n### Monthly\n- Rotate API keys\n- Update proxy sources\n- Performance testing\n\n### Backup\n\n```bash\n#!/bin/bash\nBACKUP_DIR=\"/backup/proxy-checker\"\nDATE=$(date +%Y%m%d_%H%M%S)\n\nmkdir -p $BACKUP_DIR\ncp /etc/proxy-checker/config.json $BACKUP_DIR/config_$DATE.json\ncp /var/lib/proxy-checker/proxies.json $BACKUP_DIR/proxies_$DATE.json\n\nfind $BACKUP_DIR -name \"*.json\" -mtime +7 -delete\n```\n\n## Troubleshooting\n\n### Service won't start\n```bash\njournalctl -u proxy-checker -n 50\nls -la /var/lib/proxy-checker\n```\n\n### High memory\n```bash\nps aux | grep proxy-checker\ncurl http://localhost:8080/debug/pprof/heap > heap.prof\ngo tool pprof -top heap.prof\n```\n\n### No proxies\n```bash\ncurl -H \"X-Api-Key: $KEY\" http://localhost:8080/stat\ncurl -X POST -H \"X-Api-Key: $KEY\" http://localhost:8080/reload\n```\n\n## Security\n\n- ✅ API key set and rotated\n- ✅ Non-root user\n- ✅ File permissions restricted\n- ✅ Firewall configured\n- ✅ Rate limiting enabled\n- ✅ Logs rotated\n- ✅ Metrics restricted to internal network\n\nSee OPS_CHECKLIST.md for complete operations guide."
}

