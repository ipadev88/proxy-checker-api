{
  "zmap_repo_analysis": "**Zmap-ProxyScanner Analysis**\n\n**Overview:** Zmap-ProxyScanner is a high-speed Go-based proxy validator designed to process stdin from zmap scans. It validates HTTP/SOCKS4/SOCKS5 proxies using concurrent HTTP requests.\n\n**Architecture:**\n- **Input:** Accepts IPs from 3 sources: stdin (zmap pipe), file (-in flag), or HTTP URL (-url flag)\n- **Processing:** Uses producer-consumer pattern with channels and worker threads\n- **Verification:** Tests proxies by making HTTP requests through them to a configurable test site\n- **Output:** Writes working proxies to file with optional ISP/country lookup\n\n**Key Files & Functions:**\n\n1. **main.go** (lines 54-92):\n   - Entry point, config loading, orchestration\n   - Spawns goroutines: Scanner(), Queue(), WorkerThread(), Stater()\n   - Uses 3 worker threads (wt=3) for proxy checking\n   - Command flags: -p (port), -o (output file), -in (input file), -url (fetch URL)\n\n2. **bufio_scanner.go** (lines 18-54) - **REUSABLE**:\n   - Scanner() function handles 3 input modes:\n     a) URL fetch mode: HTTP GET proxies from URL\n     b) File mode: Read proxies from local file\n     c) ZMAP mode: Read from stdin (bufio.Scanner on os.Stdin)\n   - Simple line-by-line parsing, sends to queueChan\n   - **Reusable for our stdin parsing of zmap output**\n\n3. **queue.go** (lines 11-23) - **REUSABLE**:\n   - Producer-consumer queue pattern\n   - Receives IPs via queueChan, stores in map[string]struct{} for deduplication\n   - Thread-safe with mutex protection\n   - **Pattern can be reused for buffering zmap output**\n\n4. **http.go** (lines 67-249) - **HIGHLY REUSABLE**:\n   - CheckProxyHTTP(), CheckProxySocks4(), CheckProxySocks5()\n   - **Verification logic (lines 99-138):**\n     a) Parse proxy address (IP:PORT)\n     b) Create http.Transport with proxy URL\n     c) Set DialContext with timeout (config.Timeout.HttpTimeout)\n     d) Make HTTP GET to config.CheckSite\n     e) Check response.StatusCode == 200\n     f) Record success/failure with atomic counters\n   - Uses http.ProxyURL() to route requests through proxy\n   - Timeout: 5s default (configurable)\n   - Concurrency control: atomic counter for openHttpThreads\n   - **This logic directly maps to our checker.checkFullHTTP()**\n\n5. **stat.go** (lines 23-35):\n   - Real-time stats printer (1s interval)\n   - Tracks: imported, checked, success, errors, timeouts\n   - Uses atomic counters for thread safety\n\n6. **exporter.go** (lines 12-38) - **REUSABLE**:\n   - Thread-safe file writer\n   - Opens file with O_APPEND flag\n   - Add() method writes proxy per line\n   - **Can reuse for incremental output during scan**\n\n7. **ip_printer.go** (lines 28-59):\n   - Optional ISP/country lookup via ip-api.com\n   - GetISP() fetches geolocation data\n   - **NOT needed for basic integration, optional feature**\n\n8. **config.json**:\n   - check-site: Target URL to test through proxy (https://google.com)\n   - proxy-type: http/socks4/socks5\n   - http_threads: Max concurrent checks (2000)\n   - timeout: Separate timeouts for each protocol (5s)\n   - headers: Custom User-Agent and Accept headers\n\n**Zmap Usage Pattern:**\n```bash\nzmap -p 8080 | ./ZmapProxyScanner -p 8080 -o proxies.txt\n```\n- zmap outputs IPs to stdout (one per line)\n- ZmapProxyScanner reads stdin, appends :PORT, validates\n- No zgrab used - pure Go HTTP client validation\n- Rate limiting done by zmap (-r flag), not by scanner\n\n**Concurrency Model:**\n- Configurable thread pool (http_threads: 2000)\n- Worker threads pull from shared IP map\n- Semaphore-style: while (openThreads < maxThreads) { spawn check }\n- No batching, continuous processing\n- Atomic counters for thread-safe statistics\n\n**Shortcomings & Improvements:**\n1. **No structured logging** - uses fmt.Printf, we have logrus\n2. **No metrics** - no Prometheus integration\n3. **No HTTP/2** - only HTTP/1.1 (good for proxies)\n4. **StatusCode == 200 only** - should accept 2xx/204\n5. **No adaptive concurrency** - fixed thread count\n6. **No rate limiting** - relies on zmap -r\n7. **Single test URL** - no fallback URLs\n8. **Blocking stdin read** - no timeout on zmap input\n9. **No CONNECT method** - only GET requests\n10. **Global state** - config as global var\n\n**Reusable Components:**\n✅ stdin scanner pattern (bufio_scanner.go)\n✅ queue/channel architecture (queue.go)\n✅ HTTP proxy validation logic (http.go lines 99-138)\n✅ Concurrency control with atomic counters (http.go lines 43-65)\n✅ File exporter pattern (exporter.go)\n✅ Stats tracking with atomics (stat.go)\n\n**Dependencies:**\n- h12.io/socks v1.0.3 (for SOCKS4/5 support)\n- Standard library: net/http, bufio, sync/atomic\n\n**Performance:**\n- Claims 2000-5000 working proxies per scan\n- 2000 concurrent threads default\n- 5s timeout means ~400 checks/sec sustained\n\n**Integration Strategy:**\nReuse the HTTP validation logic and stdin parsing pattern, but integrate into our existing checker framework with proper logging, metrics, and configuration management.",
  
  "integration_plan": "**Zmap Integration Implementation Plan**\n\n## Phase 1: Configuration Extensions\n\n### 1.1 Update Config Schema (internal/config/config.go)\n\nAdd new ZmapConfig struct:\n```go\ntype ZmapConfig struct {\n    Enabled            bool     `json:\"enabled\"`\n    Ports              []int    `json:\"ports\"`              // [8080, 80, 3128, 1080]\n    RateLimit          int      `json:\"rate_limit\"`         // packets/sec (default: 10000)\n    Bandwidth          string   `json:\"bandwidth\"`          // \"10M\" or \"100M\"\n    MaxRuntimeSeconds  int      `json:\"max_runtime_seconds\"` // Kill scan after N seconds\n    TargetRanges       []string `json:\"target_ranges\"`      // CIDR ranges to scan, empty = all IPv4\n    Blacklist          []string `json:\"blacklist\"`          // CIDR to exclude\n    Interface          string   `json:\"interface\"`          // Network interface (auto-detect if empty)\n    ZmapBinary         string   `json:\"zmap_binary\"`        // Path to zmap (default: /usr/local/bin/zmap)\n    ZgrabBinary        string   `json:\"zgrab_binary\"`       // Path to zgrab2 (optional)\n    UseZgrab           bool     `json:\"use_zgrab\"`          // Use zgrab2 for app-layer checks\n    OutputFormat       string   `json:\"output_format\"`      // \"csv\" or \"json\"\n    ZmapExtraArgs      []string `json:\"zmap_extra_args\"`   // Additional zmap CLI args\n    CooldownSeconds    int      `json:\"cooldown_seconds\"`   // Wait time between scans\n}\n```\n\nAdd ZmapConfig to main Config struct:\n```go\ntype Config struct {\n    Aggregator AggregatorConfig `json:\"aggregator\"`\n    Zmap       ZmapConfig       `json:\"zmap\"`  // NEW\n    Checker    CheckerConfig    `json:\"checker\"`\n    // ... existing fields\n}\n```\n\nSet defaults in Load():\n- Enabled: false (opt-in)\n- Ports: [8080, 80, 3128]\n- RateLimit: 10000 pps\n- MaxRuntimeSeconds: 3600 (1 hour)\n- ZmapBinary: \"/usr/local/bin/zmap\"\n- OutputFormat: \"csv\"\n- CooldownSeconds: 300 (5 min)\n\n### 1.2 Add Validation\n\nIn Validate():\n- Check zmap binary exists and is executable\n- Validate ports are 1-65535\n- Validate rate_limit > 0 and < 1000000\n- Validate CIDR syntax in target_ranges and blacklist\n- Warn if enabled but not running as root/no capabilities\n\n## Phase 2: Zmap Scanner Module\n\n### 2.1 Create internal/zmap/scanner.go\n\n**Core Functions:**\n\n```go\ntype ZmapScanner struct {\n    config  config.ZmapConfig\n    metrics *metrics.Collector\n    logger  *logrus.Logger\n}\n\nfunc NewZmapScanner(cfg config.ZmapConfig, m *metrics.Collector) *ZmapScanner\n\n// Scan runs zmap for all configured ports, returns candidate proxies\nfunc (z *ZmapScanner) Scan(ctx context.Context) ([]string, error)\n\n// scanPort runs zmap for single port, parses output\nfunc (z *ZmapScanner) scanPort(ctx context.Context, port int) ([]string, error)\n\n// buildZmapCmd constructs exec.Command with all flags\nfunc (z *ZmapScanner) buildZmapCmd(port int, outputFile string) *exec.Command\n\n// parseZmapOutput reads CSV/JSON and extracts IP:PORT strings\nfunc (z *ZmapScanner) parseZmapOutput(outputFile string, port int) ([]string, error)\n```\n\n**Implementation Details:**\n\n1. **buildZmapCmd():**\n   ```bash\n   zmap -p <port> \\\n     -r <rate_limit> \\\n     -B <bandwidth> \\\n     -o <output.csv> \\\n     --output-fields=saddr,sport,timestamp-str \\\n     --output-module=csv \\\n     -T <max_runtime_seconds> \\\n     -b <blacklist.txt> \\\n     <target_ranges...>\n   ```\n\n2. **Concurrency:** Run each port scan sequentially to avoid overwhelming network\n\n3. **Output Parsing:**\n   - CSV format: `saddr,sport,timestamp`\n   - Read line by line: `192.168.1.1,8080,2024-10-25 12:00:00`\n   - Construct: `192.168.1.1:8080`\n   - Deduplicate in-memory with map[string]struct{}\n\n4. **Error Handling:**\n   - Check zmap exit code (0 = success)\n   - Capture stderr for diagnostics\n   - Timeout via context.WithTimeout()\n   - Log warnings for partial results\n\n5. **Metrics:**\n   - zmap_scans_total (counter)\n   - zmap_candidates_found (gauge per port)\n   - zmap_scan_duration_seconds (histogram)\n   - zmap_errors_total (counter)\n\n### 2.2 Create internal/zmap/capabilities.go\n\n```go\n// CheckCapabilities verifies zmap can run\nfunc CheckCapabilities() error {\n    // Check if running as root\n    if os.Geteuid() == 0 {\n        return nil\n    }\n    \n    // Check for CAP_NET_RAW capability\n    // Use github.com/syndtr/gocapability/capability\n    caps, err := capability.NewPid2(0)\n    if err != nil {\n        return fmt.Errorf(\"check capabilities: %w\", err)\n    }\n    if !caps.Get(capability.EFFECTIVE, capability.CAP_NET_RAW) {\n        return fmt.Errorf(\"missing CAP_NET_RAW capability\")\n    }\n    \n    return nil\n}\n\n// CheckZmapBinary verifies zmap exists and version\nfunc CheckZmapBinary(path string) error {\n    cmd := exec.Command(path, \"--version\")\n    output, err := cmd.CombinedOutput()\n    if err != nil {\n        return fmt.Errorf(\"zmap not found at %s\", path)\n    }\n    // Parse version, ensure >= 2.1.0\n    return nil\n}\n```\n\n### 2.3 Create internal/zmap/zgrab.go (Optional)\n\n```go\n// RunZgrab2 performs application-layer validation\nfunc (z *ZmapScanner) RunZgrab2(candidates []string, port int) ([]string, error) {\n    // Build zgrab2 command:\n    // echo \"<IPs>\" | zgrab2 http -p <port> --timeout 5s \\\n    //   --use-https=false --endpoint /generate_204\n    \n    // Parse JSON output for successful HTTP responses\n    // Return validated IPs\n}\n```\n\n## Phase 3: Orchestration Integration\n\n### 3.1 Update cmd/main.go\n\n**Add zmap scanner initialization:**\n```go\nvar zmapScanner *zmap.ZmapScanner\nif cfg.Zmap.Enabled {\n    // Check capabilities\n    if err := zmap.CheckCapabilities(); err != nil {\n        log.Warnf(\"Zmap disabled: %v\", err)\n        cfg.Zmap.Enabled = false\n    } else {\n        zmapScanner = zmap.NewZmapScanner(cfg.Zmap, metricsCollector)\n        log.Info(\"Zmap scanner enabled\")\n    }\n}\n```\n\n**Update aggregation loop:**\n```go\nfunc aggregationLoop() {\n    for {\n        ctx, cancel := context.WithTimeout(context.Background(), 2*time.Hour)\n        \n        // PHASE 1: Scrape from URLs\n        scrapedProxies, sourceStats := aggregator.Aggregate(ctx)\n        log.Infof(\"Scraped %d proxies\", len(scrapedProxies))\n        \n        // PHASE 2: Zmap scan (if enabled)\n        var zmapProxies []string\n        if zmapScanner != nil {\n            zmapProxies, err = zmapScanner.Scan(ctx)\n            if err != nil {\n                log.Errorf(\"Zmap scan failed: %v\", err)\n            } else {\n                log.Infof(\"Zmap found %d candidates\", len(zmapProxies))\n            }\n        }\n        \n        // PHASE 3: Merge and deduplicate\n        allProxies := append(scrapedProxies, zmapProxies...)\n        uniqueProxies := deduplicateProxies(allProxies)\n        log.Infof(\"Total unique: %d\", len(uniqueProxies))\n        \n        // PHASE 4: Two-stage checking\n        // Stage 1: Fast TCP connect filter (if enabled)\n        if cfg.Checker.EnableFastFilter {\n            uniqueProxies = fastConnectFilter(uniqueProxies)\n        }\n        \n        // Stage 2: Full HTTP validation\n        results := checker.CheckProxies(ctx, uniqueProxies)\n        \n        // PHASE 5: Update snapshot\n        snapshot.Update(results, sourceStats)\n        \n        cancel()\n        \n        // Wait for next cycle\n        time.Sleep(time.Duration(cfg.Aggregator.IntervalSeconds) * time.Second)\n    }\n}\n```\n\n### 3.2 Add Two-Stage Checking\n\nCreate internal/checker/fastfilter.go:\n```go\n// FastConnectFilter performs TCP-only pre-filtering\nfunc FastConnectFilter(proxies []string, timeoutMs int, concurrency int) []string {\n    // Parallel TCP dial checks with shorter timeout (e.g., 2s)\n    // Return only proxies that accept connections\n    // This reduces load on full HTTP checker\n}\n```\n\nAdd to CheckerConfig:\n```go\nEnableFastFilter      bool `json:\"enable_fast_filter\"`\nFastFilterTimeoutMs   int  `json:\"fast_filter_timeout_ms\"`  // Default: 2000\nFastFilterConcurrency int  `json:\"fast_filter_concurrency\"` // Default: 50000\n```\n\n## Phase 4: API Enhancements\n\n### 4.1 Update internal/api/server.go\n\n**Add POST /reload with mode parameter:**\n```go\nfunc (s *Server) handleReload(c *gin.Context) {\n    var req struct {\n        Mode string `json:\"mode\"` // \"scrape-only\", \"zmap-only\", \"both\", \"\" (default both)\n    }\n    c.BindJSON(&req)\n    \n    // Trigger aggregation with specific mode\n    go func() {\n        switch req.Mode {\n        case \"scrape-only\":\n            // Run aggregator only\n        case \"zmap-only\":\n            // Run zmap only\n        default:\n            // Run both\n        }\n    }()\n    \n    c.JSON(200, gin.H{\"status\": \"reload triggered\", \"mode\": req.Mode})\n}\n```\n\n**Add GET /stats/zmap:**\n```go\nfunc (s *Server) handleZmapStats(c *gin.Context) {\n    if !config.Zmap.Enabled {\n        c.JSON(404, gin.H{\"error\": \"zmap not enabled\"})\n        return\n    }\n    \n    stats := gin.H{\n        \"enabled\": true,\n        \"ports\": config.Zmap.Ports,\n        \"last_scan_time\": zmapScanner.LastScanTime(),\n        \"last_scan_duration\": zmapScanner.LastScanDuration(),\n        \"candidates_found\": zmapScanner.LastCandidatesCount(),\n        \"total_scans\": zmapScanner.TotalScans(),\n    }\n    c.JSON(200, stats)\n}\n```\n\n## Phase 5: Metrics & Monitoring\n\n### 5.1 Add Zmap Metrics (internal/metrics/metrics.go)\n\n```go\n// Zmap-specific metrics\nzmapScansTotal := prometheus.NewCounterVec(\n    prometheus.CounterOpts{\n        Name: \"zmap_scans_total\",\n        Help: \"Total number of zmap scans executed\",\n    },\n    []string{\"port\", \"status\"}, // status: success/error/timeout\n)\n\nzmapCandidatesFound := prometheus.NewGaugeVec(\n    prometheus.GaugeOpts{\n        Name: \"zmap_candidates_found\",\n        Help: \"Number of candidate proxies found by zmap\",\n    },\n    []string{\"port\"},\n)\n\nzmapScanDuration := prometheus.NewHistogramVec(\n    prometheus.HistogramOpts{\n        Name: \"zmap_scan_duration_seconds\",\n        Help: \"Duration of zmap scans\",\n        Buckets: []float64{10, 30, 60, 120, 300, 600, 1800, 3600},\n    },\n    []string{\"port\"},\n)\n```\n\n### 5.2 Update Grafana Dashboard\n\nAdd panels:\n- Zmap scan frequency (scans/hour)\n- Candidates found per port (gauge)\n- Zmap scan duration (heatmap)\n- Zmap error rate (rate)\n- Scrape vs Zmap contribution (pie chart)\n\n## Phase 6: Safety & Legal\n\n### 6.1 Create internal/zmap/safety.go\n\n```go\n// LoadBlacklist loads CIDR ranges to exclude\nfunc LoadBlacklist(path string) ([]string, error) {\n    // Read file with CIDRs\n    // Include default ranges:\n    // - 0.0.0.0/8 (this network)\n    // - 10.0.0.0/8 (private)\n    // - 127.0.0.0/8 (loopback)\n    // - 169.254.0.0/16 (link-local)\n    // - 172.16.0.0/12 (private)\n    // - 192.168.0.0/16 (private)\n    // - 224.0.0.0/4 (multicast)\n    // - 240.0.0.0/4 (reserved)\n}\n\n// ValidateTargets ensures scan targets are legal\nfunc ValidateTargets(ranges []string) error {\n    // Reject if:\n    // - Includes government/military domains (.mil, .gov)\n    // - Known CDN ranges without permission\n    // - Healthcare/finance networks\n}\n```\n\n### 6.2 Add Documentation (docs/LEGAL_SCANNING.md)\n\n```markdown\n# Legal & Ethical Scanning Guidelines\n\n## Warning\nNetwork scanning may be illegal in some jurisdictions. You are responsible\nfor ensuring compliance with local laws and obtaining necessary permissions.\n\n## Best Practices\n1. Only scan networks you own or have written permission to scan\n2. Use allow-lists (target_ranges) instead of scanning entire internet\n3. Implement rate limiting (rate_limit <= 10000 pps recommended)\n4. Maintain comprehensive blacklists\n5. Honor opt-out requests immediately\n6. Monitor for complaints and respond promptly\n7. Keep detailed logs for audit trails\n8. Consider scanning during off-peak hours\n\n## Recommended Configuration\n- rate_limit: 5000 (conservative)\n- max_runtime_seconds: 1800 (30 min)\n- cooldown_seconds: 3600 (1 hour between scans)\n- blacklist: Include all private/reserved ranges\n\n## Countries with Strict Anti-Hacking Laws\n- USA: Computer Fraud and Abuse Act (CFAA)\n- EU: NIS Directive, GDPR considerations\n- UK: Computer Misuse Act\n- Germany: Criminal Code Section 202a-c\n- [Full list...]\n\n## Recommended: Notify & Opt-Out\nSet up abuse@yourdomain.com and honor opt-out requests within 24 hours.\n```\n\n## Phase 7: Testing & Validation\n\n### 7.1 Unit Tests\n\n**internal/zmap/scanner_test.go:**\n- Test parseZmapOutput() with mock CSV data\n- Test buildZmapCmd() arguments\n- Test deduplication logic\n- Test error handling for missing binary\n\n**internal/zmap/capabilities_test.go:**\n- Mock capability checks\n- Test binary version detection\n\n### 7.2 Integration Tests\n\n**tests/integration/zmap_test.go:**\n```go\nfunc TestZmapIntegration(t *testing.T) {\n    if os.Getenv(\"RUN_ZMAP_TESTS\") != \"1\" {\n        t.Skip(\"Set RUN_ZMAP_TESTS=1 to run\")\n    }\n    \n    // Test scan of localhost:8080 (test server)\n    // Verify output contains 127.0.0.1:8080\n    // Verify metrics recorded\n}\n```\n\n### 7.3 Mock Zmap Output Testing\n\nCreate testdata/zmap_output.csv:\n```csv\nsaddr,sport,timestamp-str\n192.168.1.1,8080,2024-10-25 12:00:00\n192.168.1.2,8080,2024-10-25 12:00:01\n10.0.0.1,8080,2024-10-25 12:00:02\n```\n\nTest parsing:\n```go\nfunc TestParseZmapCSV(t *testing.T) {\n    proxies, err := parseZmapOutput(\"testdata/zmap_output.csv\", 8080)\n    assert.NoError(t, err)\n    assert.Len(t, proxies, 3)\n    assert.Contains(t, proxies, \"192.168.1.1:8080\")\n}\n```\n\n### 7.4 E2E Smoke Test\n\nCreate scripts/zmap_smoke_test.sh:\n```bash\n#!/bin/bash\n# Prerequisites: zmap installed, root/CAP_NET_RAW\n\nset -e\n\n# Start local test HTTP server on 8080\npython3 -m http.server 8080 &\nSERVER_PID=$!\ntrap \"kill $SERVER_PID\" EXIT\n\nsleep 2\n\n# Run zmap on localhost range\nsudo zmap -p 8080 \\\n  -r 1000 \\\n  -o /tmp/zmap_test.csv \\\n  --output-fields=saddr,sport \\\n  --output-module=csv \\\n  127.0.0.0/24\n\n# Verify output\ngrep -q \"127.0.0.1\" /tmp/zmap_test.csv\necho \"✅ Zmap smoke test passed\"\n```\n\n## Phase 8: Deployment\n\n### 8.1 System Requirements\n\n```markdown\n- zmap >= 2.1.0 (install: apt install zmap)\n- zgrab2 >= 0.1.0 (optional, install: go install github.com/zmap/zgrab2@latest)\n- Linux kernel >= 3.0\n- Root access OR CAP_NET_RAW + CAP_NET_ADMIN capabilities\n- ulimit -n >= 100000 (file descriptors)\n- Recommended: 12+ CPU cores, 8GB RAM, 1Gbps network\n```\n\n### 8.2 Installation Steps\n\n```bash\n# 1. Install zmap\nsudo apt update\nsudo apt install -y zmap\nzmap --version  # Verify >= 2.1.0\n\n# 2. (Optional) Install zgrab2\ngo install github.com/zmap/zgrab2@latest\nsudo cp ~/go/bin/zgrab2 /usr/local/bin/\n\n# 3. Set capabilities on proxy-checker binary\nsudo setcap 'cap_net_raw,cap_net_admin=+ep' /usr/local/bin/proxy-checker\n\n# 4. Configure blacklist\nsudo mkdir -p /etc/proxy-checker\nsudo wget -O /etc/proxy-checker/blacklist.txt \\\n  https://raw.githubusercontent.com/zmap/zmap/master/conf/blacklist.conf\n\n# 5. Update config.json\nvim /etc/proxy-checker/config.json\n# Set zmap.enabled = true\n# Set zmap.blacklist = [\"/etc/proxy-checker/blacklist.txt\"]\n\n# 6. Start service\nsudo systemctl restart proxy-checker\nsudo journalctl -u proxy-checker -f\n```\n\n### 8.3 Docker Deployment\n\nSee \"docker_notes\" section below.\n\n## Phase 9: Monitoring & Alerting\n\n### 9.1 Key Metrics to Monitor\n\n1. **zmap_scans_total{status=\"error\"}** - Alert if > 0\n2. **zmap_scan_duration_seconds** - Alert if > 3600s\n3. **zmap_candidates_found** - Alert if = 0 (scan failed)\n4. **node_network_transmit_packets_total** - Monitor network load\n5. **process_open_fds** - Alert if > 80% of ulimit\n\n### 9.2 Prometheus Alerts\n\nAdd to alerts.yml:\n```yaml\ngroups:\n  - name: zmap\n    interval: 60s\n    rules:\n      - alert: ZmapScanFailed\n        expr: increase(zmap_scans_total{status=\"error\"}[5m]) > 0\n        for: 5m\n        annotations:\n          summary: \"Zmap scan failures detected\"\n          \n      - alert: ZmapNoResults\n        expr: zmap_candidates_found == 0\n        for: 30m\n        annotations:\n          summary: \"Zmap returning no results\"\n```\n\n## Phase 10: Optimization & Tuning\n\n### 10.1 Network Tuning\n\n```bash\n# Increase socket buffers\nsudo sysctl -w net.core.rmem_max=134217728\nsudo sysctl -w net.core.wmem_max=134217728\nsudo sysctl -w net.ipv4.tcp_rmem='4096 87380 67108864'\nsudo sysctl -w net.ipv4.tcp_wmem='4096 65536 67108864'\n\n# Increase connection tracking\nsudo sysctl -w net.netfilter.nf_conntrack_max=1000000\n\n# Increase local port range\nsudo sysctl -w net.ipv4.ip_local_port_range='1024 65535'\n\n# Enable TCP fast open\nsudo sysctl -w net.ipv4.tcp_fastopen=3\n```\n\n### 10.2 Performance Targets\n\n**With zmap:**\n- Zmap scan rate: 10,000 pps (default)\n- Coverage: 4.3 billion IPv4 addresses in ~5 days at 10k pps\n- Practical: Scan top 1 million Alexa + known proxy ranges in 1-2 hours\n- Candidate generation: 50k-200k potential proxies per full scan\n- Validation: 15k-25k concurrent checks = 3k-5k checks/sec\n- End-to-end: Find 5k-10k working proxies in 2-3 hours\n\n**Without zmap (scraping only):**\n- Current: 1.3k working proxies in 45 seconds (established)\n- Limited by source quality, not scanning capability\n\n### 10.3 Recommended Workflow\n\n**Hourly (scrape-only):**\n```json\n{\n  \"aggregator\": { \"interval_seconds\": 60 },\n  \"zmap\": { \"enabled\": false }\n}\n```\n\n**Daily (zmap + scrape):**\n```json\n{\n  \"aggregator\": { \"interval_seconds\": 86400 },\n  \"zmap\": {\n    \"enabled\": true,\n    \"ports\": [8080, 3128, 80],\n    \"rate_limit\": 10000,\n    \"max_runtime_seconds\": 7200,\n    \"target_ranges\": [\"loadfromfile.txt\"]\n  }\n}\n```\n\n## Summary\n\nThis integration will:\n1. ✅ Maintain backward compatibility (zmap is opt-in)\n2. ✅ Reuse existing checker infrastructure\n3. ✅ Add 50k-200k candidate proxies per scan\n4. ✅ Provide 10-20x more working proxies\n5. ✅ Keep API semantics unchanged\n6. ✅ Add comprehensive monitoring\n7. ✅ Include safety/legal guardrails\n8. ✅ Support both Docker and systemd deployment\n9. ✅ Maintain 3k+ checks/sec performance\n10. ✅ Enable hybrid scrape+scan workflow\n\n**Estimated Implementation Time:** 16-20 hours\n**Files to Create:** 8\n**Files to Modify:** 6\n**Total LOC:** ~2000 lines",
  
  "config_example": {
    "aggregator": {
      "interval_seconds": 3600,
      "sources": [
        {
          "url": "https://api.proxyscrape.com/v2/?request=get&protocol=http&timeout=10000&country=all&ssl=all&anonymity=all",
          "type": "http",
          "enabled": true
        },
        {
          "url": "https://raw.githubusercontent.com/TheSpeedX/PROXY-List/master/http.txt",
          "type": "http",
          "enabled": true
        }
      ],
      "user_agent": "ProxyChecker/2.0"
    },
    "zmap": {
      "enabled": true,
      "ports": [8080, 3128, 80, 1080, 8888, 9090],
      "rate_limit": 10000,
      "bandwidth": "10M",
      "max_runtime_seconds": 7200,
      "target_ranges": [
        "1.0.0.0/8",
        "2.0.0.0/8"
      ],
      "blacklist": [
        "/etc/proxy-checker/blacklist.txt"
      ],
      "interface": "",
      "zmap_binary": "/usr/local/bin/zmap",
      "zgrab_binary": "/usr/local/bin/zgrab2",
      "use_zgrab": false,
      "output_format": "csv",
      "zmap_extra_args": [
        "--seed=12345",
        "--cooldown-time=8"
      ],
      "cooldown_seconds": 3600
    },
    "checker": {
      "timeout_ms": 6000,
      "concurrency_total": 20000,
      "batch_size": 2000,
      "retries": 0,
      "test_url": "http://www.gstatic.com/generate_204",
      "mode": "full-http",
      "enable_adaptive_concurrency": true,
      "enable_fast_filter": true,
      "fast_filter_timeout_ms": 2000,
      "fast_filter_concurrency": 50000,
      "max_fd_usage_percent": 70,
      "max_cpu_usage_percent": 75
    },
    "api": {
      "addr": ":8083",
      "api_key_env": "API_KEY",
      "rate_limit_per_minute": 1200,
      "rate_limit_per_ip": 100,
      "enable_api_key_auth": true,
      "enable_ip_rate_limit": true
    },
    "storage": {
      "type": "file",
      "path": "/data/proxies.json",
      "persist_interval_seconds": 300
    },
    "metrics": {
      "enabled": true,
      "endpoint": "/metrics",
      "namespace": "proxychecker"
    },
    "logging": {
      "level": "info",
      "format": "json"
    }
  },
  
  "zmap_cli_examples": [
    "# Basic scan of port 8080 across entire IPv4 space",
    "sudo zmap -p 8080 -o /tmp/proxies_8080.csv --output-fields=saddr,sport,timestamp-str --output-module=csv -r 10000",
    "",
    "# Scan multiple ports sequentially",
    "for PORT in 8080 3128 80; do sudo zmap -p $PORT -o /tmp/proxies_$PORT.csv --output-fields=saddr --output-module=csv -r 10000 -T 1800; done",
    "",
    "# Scan specific CIDR ranges with blacklist",
    "sudo zmap -p 8080 -o /tmp/proxies.csv --output-fields=saddr --output-module=csv -r 10000 -b /etc/proxy-checker/blacklist.txt 1.0.0.0/8 2.0.0.0/8",
    "",
    "# Scan with bandwidth limit (10 Mbps)",
    "sudo zmap -p 8080 -o /tmp/proxies.csv --output-fields=saddr --output-module=csv -r 10000 -B 10M",
    "",
    "# Scan with metadata (includes timestamp, TTL)",
    "sudo zmap -p 8080 -o /tmp/proxies.csv --output-fields=saddr,sport,ttl,timestamp-str --output-module=csv -r 10000",
    "",
    "# Pipe zmap output to our checker (legacy mode, like Zmap-ProxyScanner)",
    "sudo zmap -p 8080 | ./proxy-checker zmap-stdin -p 8080",
    "",
    "# Use zgrab2 for application-layer HTTP validation",
    "sudo zmap -p 8080 -o /tmp/ips.txt --output-fields=saddr --output-module=csv -r 10000 && cat /tmp/ips.txt | zgrab2 http -p 8080 --timeout 5s --use-https=false --endpoint=/generate_204 -o /tmp/http_results.json",
    "",
    "# Conservative scan (low rate, short duration)",
    "sudo zmap -p 8080 -o /tmp/proxies.csv --output-fields=saddr --output-module=csv -r 5000 -T 1800 -b /etc/proxy-checker/blacklist.txt",
    "",
    "# Aggressive scan (high rate, long duration) - USE WITH CAUTION",
    "sudo zmap -p 8080 -o /tmp/proxies.csv --output-fields=saddr --output-module=csv -r 50000 -B 100M -T 7200",
    "",
    "# Scan with custom source port and seed",
    "sudo zmap -p 8080 -o /tmp/proxies.csv --output-fields=saddr --output-module=csv -r 10000 -s 61000 --seed=12345",
    "",
    "# Scan and parse in Go application (integrated mode)",
    "# Application runs: buildZmapCmd() -> exec.Command() -> parseZmapOutput()"
  ],
  
  "file_changes": [
    {
      "path": "internal/config/config.go",
      "action": "modify",
      "summary": "Add ZmapConfig struct with fields: enabled, ports[], rate_limit, bandwidth, max_runtime_seconds, target_ranges[], blacklist[], interface, zmap_binary, zgrab_binary, use_zgrab, output_format, zmap_extra_args[], cooldown_seconds. Add defaults and validation. Add EnableFastFilter, FastFilterTimeoutMs, FastFilterConcurrency to CheckerConfig."
    },
    {
      "path": "internal/zmap/scanner.go",
      "action": "create",
      "summary": "Core zmap integration. Implements ZmapScanner struct with methods: NewZmapScanner(), Scan(ctx), scanPort(ctx, port), buildZmapCmd(port, outputFile), parseZmapOutput(outputFile, port). Handles exec of zmap binary, output parsing (CSV/JSON), error handling, timeout via context, deduplication."
    },
    {
      "path": "internal/zmap/capabilities.go",
      "action": "create",
      "summary": "Capability checking functions: CheckCapabilities() verifies CAP_NET_RAW via github.com/syndtr/gocapability or root access. CheckZmapBinary(path) verifies zmap exists and version >= 2.1.0."
    },
    {
      "path": "internal/zmap/zgrab.go",
      "action": "create",
      "summary": "Optional zgrab2 integration. RunZgrab2(candidates, port) pipes IPs to zgrab2 for application-layer HTTP validation, parses JSON output, returns validated IPs. Used when config.zmap.use_zgrab=true."
    },
    {
      "path": "internal/zmap/safety.go",
      "action": "create",
      "summary": "Safety utilities: LoadBlacklist(path) reads CIDR ranges to exclude (includes default private/reserved ranges). ValidateTargets(ranges) checks for illegal/restricted networks (.mil, .gov, healthcare, finance)."
    },
    {
      "path": "internal/checker/fastfilter.go",
      "action": "create",
      "summary": "FastConnectFilter(proxies, timeoutMs, concurrency) performs TCP-only connection tests with shorter timeout (2s) and higher concurrency (50k). Returns only connectable proxies for full HTTP validation. Reduces load on main checker."
    },
    {
      "path": "cmd/main.go",
      "action": "modify",
      "summary": "Add zmapScanner initialization with capability checks. Update aggregationLoop() to: 1) scrape from URLs, 2) run zmap scan if enabled, 3) merge+dedupe, 4) run fast filter if enabled, 5) run full HTTP checker, 6) update snapshot. Add zmap cooldown between scans."
    },
    {
      "path": "internal/api/server.go",
      "action": "modify",
      "summary": "Add mode parameter to POST /reload with options: scrape-only, zmap-only, both (default). Add GET /stats/zmap endpoint returning: enabled, ports, last_scan_time, last_scan_duration, candidates_found, total_scans."
    },
    {
      "path": "internal/metrics/metrics.go",
      "action": "modify",
      "summary": "Add zmap-specific Prometheus metrics: zmap_scans_total{port, status}, zmap_candidates_found{port}, zmap_scan_duration_seconds{port} histogram, zmap_errors_total{type}. Add RecordZmapScan(), RecordZmapCandidates(), RecordZmapDuration() methods."
    },
    {
      "path": "go.mod",
      "action": "modify",
      "summary": "Add dependencies: github.com/syndtr/gocapability/capability for capability checks. Optionally h12.io/socks for SOCKS proxy support (if implementing SOCKS validation from Zmap-ProxyScanner)."
    },
    {
      "path": "Dockerfile",
      "action": "modify",
      "summary": "Add zmap and zgrab2 installation in build stage. Install dependencies: apt-get install -y zmap libpcap-dev. Download zgrab2 binary or build from source. Set capabilities on final binary or document need for --cap-add=NET_RAW. Add blacklist.txt to image."
    },
    {
      "path": "docker-compose.yml",
      "action": "modify",
      "summary": "Add cap_add: [NET_RAW, NET_ADMIN] to proxy-checker service. Add privileged: true option with warning comment. Mount blacklist.txt volume. Add environment variable ENABLE_ZMAP=true."
    },
    {
      "path": "config.example.json",
      "action": "modify",
      "summary": "Add complete zmap configuration section with all fields and sensible defaults. Add fast_filter options to checker config. Add comments explaining legal/safety considerations."
    },
    {
      "path": "README.md",
      "action": "modify",
      "summary": "Add Zmap Integration section covering: overview, requirements (zmap, capabilities), configuration, usage examples, performance expectations, legal warnings, troubleshooting. Update performance metrics to reflect zmap-enhanced numbers."
    },
    {
      "path": "docs/LEGAL_SCANNING.md",
      "action": "create",
      "summary": "Comprehensive legal and ethical guidelines document. Covers: legal warnings by jurisdiction, best practices, rate limiting recommendations, blacklist management, opt-out procedures, complaint handling, audit logging, liability disclaimers."
    },
    {
      "path": "scripts/install_zmap.sh",
      "action": "create",
      "summary": "Automated installation script for zmap and zgrab2 on Ubuntu/Debian. Checks versions, downloads from official sources, compiles if needed, sets up blacklist.txt, configures capabilities, validates installation."
    },
    {
      "path": "scripts/zmap_smoke_test.sh",
      "action": "create",
      "summary": "E2E smoke test script. Starts local HTTP server on 8080, runs zmap scan on 127.0.0.0/24, verifies output contains 127.0.0.1:8080, cleans up. Requires root/capabilities."
    },
    {
      "path": "testdata/zmap_output.csv",
      "action": "create",
      "summary": "Mock zmap CSV output for unit testing. Contains sample rows with saddr,sport,timestamp-str format. Used by scanner_test.go to test parsing logic."
    },
    {
      "path": "internal/zmap/scanner_test.go",
      "action": "create",
      "summary": "Unit tests for zmap scanner: TestParseZmapCSV, TestBuildZmapCmd, TestDeduplication, TestErrorHandling, TestCapabilityCheck. Uses mock data, no actual zmap execution."
    },
    {
      "path": "tests/integration/zmap_test.go",
      "action": "create",
      "summary": "Integration tests requiring actual zmap binary. Gated by RUN_ZMAP_TESTS=1 env var. Tests: full scan cycle, output parsing, metrics recording, timeout handling. Scans localhost only."
    },
    {
      "path": "proxy-checker.service",
      "action": "modify",
      "summary": "Add AmbientCapabilities=CAP_NET_RAW CAP_NET_ADMIN to [Service] section. Add Environment=ENABLE_ZMAP=true. Add Requires=network-online.target. Add documentation comments about capabilities."
    },
    {
      "path": "setup-ubuntu.sh",
      "action": "modify",
      "summary": "Add zmap installation steps: apt install zmap, download zgrab2, download blacklist.txt to /etc/proxy-checker/, run capability checks, set capabilities on binary. Add validation steps."
    },
    {
      "path": "alerts.yml",
      "action": "modify",
      "summary": "Add Prometheus alert rules: ZmapScanFailed (errors > 0), ZmapNoResults (candidates = 0), ZmapSlowScan (duration > 3600s), ZmapHighErrorRate (error rate > 50%)."
    },
    {
      "path": "grafana-dashboard.json",
      "action": "modify",
      "summary": "Add panels: Zmap Scans (counter), Candidates Found by Port (gauge multi-series), Zmap Scan Duration (heatmap), Zmap vs Scrape Contribution (pie chart), Zmap Error Rate (graph). Add row for Zmap Metrics."
    }
  ],
  
  "docker_notes": "**Docker Deployment with Zmap Capabilities**\n\n## Challenge\nZmap requires CAP_NET_RAW and CAP_NET_ADMIN capabilities to send raw packets. Docker containers run unprivileged by default.\n\n## Solution 1: Add Capabilities (Recommended)\n\n### Dockerfile\n```dockerfile\nFROM golang:1.21-alpine AS builder\n\n# Install build dependencies\nRUN apk add --no-cache \\\n    git \\\n    make \\\n    gcc \\\n    musl-dev \\\n    sqlite-dev \\\n    libpcap-dev\n\n# Install zmap from source (Alpine doesn't have zmap package)\nWORKDIR /tmp\nRUN apk add --no-cache \\\n    cmake \\\n    flex \\\n    byacc \\\n    gmp-dev \\\n    gengetopt \\\n    json-c-dev \\\n    libpcap-dev\n\nRUN git clone https://github.com/zmap/zmap.git && \\\n    cd zmap && \\\n    cmake . && \\\n    make && \\\n    make install\n\n# Verify zmap\nRUN zmap --version\n\n# Optional: Install zgrab2\nRUN go install github.com/zmap/zgrab2@latest && \\\n    cp /go/bin/zgrab2 /usr/local/bin/\n\n# Build proxy-checker\nWORKDIR /build\nCOPY go.mod go.sum ./\nRUN go mod download\nCOPY . .\nRUN CGO_ENABLED=1 GOOS=linux go build -a -ldflags=\"-s -w\" -o proxy-checker ./cmd/main.go\n\n# Runtime stage\nFROM alpine:latest\n\nRUN apk add --no-cache \\\n    ca-certificates \\\n    tzdata \\\n    libpcap \\\n    libstdc++ \\\n    gmp \\\n    json-c \\\n    wget \\\n    libcap\n\n# Copy binaries\nCOPY --from=builder /usr/local/bin/zmap /usr/local/bin/zmap\nCOPY --from=builder /usr/local/bin/zgrab2 /usr/local/bin/zgrab2\nCOPY --from=builder /build/proxy-checker /usr/local/bin/proxy-checker\n\n# Download default blacklist\nRUN mkdir -p /etc/proxy-checker && \\\n    wget -O /etc/proxy-checker/blacklist.txt \\\n    https://raw.githubusercontent.com/zmap/zmap/master/conf/blacklist.conf\n\n# Set capabilities on binaries (alternative to privileged mode)\n# Note: This requires docker run with --cap-add=NET_RAW --cap-add=NET_ADMIN\nRUN setcap 'cap_net_raw,cap_net_admin=+eip' /usr/local/bin/zmap\nRUN setcap 'cap_net_raw,cap_net_admin=+eip' /usr/local/bin/proxy-checker\n\nWORKDIR /app\n\nEXPOSE 8083\nHEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \\\n  CMD wget --no-verbose --tries=1 --spider http://localhost:8083/health || exit 1\n\nCMD [\"/usr/local/bin/proxy-checker\", \"-config\", \"/app/config.json\"]\n```\n\n### docker-compose.yml\n```yaml\nversion: '3.8'\n\nservices:\n  proxy-checker:\n    build: .\n    container_name: proxy-checker\n    # Grant network capabilities for zmap\n    cap_add:\n      - NET_RAW\n      - NET_ADMIN\n    # Alternative: privileged mode (less secure, not recommended)\n    # privileged: true\n    environment:\n      - API_KEY=${API_KEY:-your-secret-key}\n      - ENABLE_ZMAP=true\n    ports:\n      - \"8083:8083\"\n    volumes:\n      - ./config.json:/app/config.json:ro\n      - ./data:/data\n      - ./blacklist.txt:/etc/proxy-checker/blacklist.txt:ro\n    networks:\n      - proxy-net\n    restart: unless-stopped\n    # Host network mode (required for some zmap operations)\n    # network_mode: host  # Uncomment if cap_add doesn't work\n\n  redis:\n    image: redis:7-alpine\n    networks:\n      - proxy-net\n    restart: unless-stopped\n\n  prometheus:\n    image: prom/prometheus:latest\n    volumes:\n      - ./prometheus.yml:/etc/prometheus/prometheus.yml:ro\n    ports:\n      - \"9090:9090\"\n    networks:\n      - proxy-net\n\n  grafana:\n    image: grafana/grafana:latest\n    ports:\n      - \"3000:3000\"\n    volumes:\n      - ./grafana-dashboard.json:/etc/grafana/provisioning/dashboards/proxy-checker.json\n    networks:\n      - proxy-net\n\nnetworks:\n  proxy-net:\n    driver: bridge\n```\n\n## Solution 2: Privileged Mode (Not Recommended)\n\nSet `privileged: true` in docker-compose.yml:\n```yaml\nproxy-checker:\n  privileged: true\n```\n\n**Warning:** Privileged mode grants full access to host. Only use in controlled environments.\n\n## Solution 3: Host Network Mode\n\nFor best zmap performance:\n```yaml\nproxy-checker:\n  network_mode: host\n  cap_add:\n    - NET_RAW\n    - NET_ADMIN\n```\n\n**Note:** Port mapping doesn't work in host mode. Service binds directly to host ports.\n\n## Build & Run\n\n```bash\n# Build image\ndocker-compose build\n\n# Run with capabilities\ndocker-compose up -d\n\n# Verify zmap works\ndocker exec -it proxy-checker zmap --version\n\n# Test scan (localhost only)\ndocker exec -it proxy-checker zmap -p 8083 -r 100 127.0.0.0/24\n\n# Check logs\ndocker-compose logs -f proxy-checker\n```\n\n## Troubleshooting\n\n### Error: \"Operation not permitted\" when zmap runs\n**Solution:** Add cap_add to docker-compose.yml or run with --privileged\n\n### Error: zmap not found\n**Solution:** Verify zmap was copied from builder stage:\n```bash\ndocker exec -it proxy-checker which zmap\ndocker exec -it proxy-checker zmap --version\n```\n\n### Error: \"Cannot open device\"\n**Solution:** Use host network mode or verify network capabilities\n\n### Performance: Slow scanning\n**Solution:** \n- Use host network mode for best performance\n- Increase rate_limit in config\n- Check host system ulimits\n- Monitor CPU/network with `docker stats`\n\n## Security Best Practices\n\n1. **Minimal Capabilities:** Only add NET_RAW and NET_ADMIN, not full privileged\n2. **Read-only Config:** Mount config.json as :ro\n3. **Dedicated Network:** Use isolated Docker network\n4. **Resource Limits:** Set memory and CPU limits:\n   ```yaml\n   deploy:\n     resources:\n       limits:\n         cpus: '8'\n         memory: 8G\n   ```\n5. **Secrets Management:** Use Docker secrets for API_KEY:\n   ```yaml\n   secrets:\n     - api_key\n   environment:\n     - API_KEY_FILE=/run/secrets/api_key\n   ```\n\n## Kubernetes Deployment\n\nFor k8s, use SecurityContext:\n```yaml\napiVersion: v1\nkind: Pod\nmetadata:\n  name: proxy-checker\nspec:\n  containers:\n  - name: proxy-checker\n    image: proxy-checker:latest\n    securityContext:\n      capabilities:\n        add:\n        - NET_RAW\n        - NET_ADMIN\n    # Or use hostNetwork: true\n  hostNetwork: true\n```\n\n## Testing Capabilities\n\n```bash\n# Test from inside container\ndocker exec -it proxy-checker sh\n\n# Check capabilities\ngetcap /usr/local/bin/zmap\n# Should show: cap_net_admin,cap_net_raw=eip\n\n# Test zmap\nzmap -p 8083 -r 100 127.0.0.0/24\n\n# Should output IPs, not \"Operation not permitted\"\n```\n\n## Production Checklist\n\n- [ ] Capabilities configured (NET_RAW, NET_ADMIN)\n- [ ] Blacklist.txt mounted and up-to-date\n- [ ] Resource limits set (CPU, memory)\n- [ ] Health checks enabled\n- [ ] Logging configured (json format)\n- [ ] Metrics exposed (:8083/metrics)\n- [ ] API key set via secrets\n- [ ] Restart policy configured\n- [ ] Backup storage volume\n- [ ] Monitor zmap_scans_total metric\n- [ ] Alert on zmap_scans_total{status=\"error\"}\n- [ ] Legal compliance verified",
  
  "systemd_unit": "[Unit]\nDescription=Proxy Checker API with Zmap Integration\nDocumentation=https://github.com/yourusername/proxy-checker-api\nAfter=network-online.target\nWants=network-online.target\nRequires=redis.service\n\n[Service]\nType=simple\nUser=proxy-checker\nGroup=proxy-checker\n\n# Working directory\nWorkingDirectory=/opt/proxy-checker\n\n# Binary location\nExecStart=/usr/local/bin/proxy-checker -config /etc/proxy-checker/config.json\n\n# Restart policy\nRestart=always\nRestartSec=10s\nStartLimitInterval=5min\nStartLimitBurst=5\n\n# Environment\nEnvironment=\"API_KEY_FILE=/etc/proxy-checker/api-key.txt\"\nEnvironment=\"LOG_LEVEL=info\"\nEnvironment=\"GOMAXPROCS=12\"\n\n# Capabilities for zmap (instead of running as root)\n# CRITICAL: These capabilities allow raw packet sending\nAmbientCapabilities=CAP_NET_RAW CAP_NET_ADMIN\nCapabilityBoundingSet=CAP_NET_RAW CAP_NET_ADMIN\nSecureBits=keep-caps\n\n# Security hardening\nNoNewPrivileges=true\nPrivateTmp=true\nProtectSystem=strict\nProtectHome=true\nReadWritePaths=/data /var/log/proxy-checker\nReadOnlyPaths=/etc/proxy-checker\n\n# Resource limits\nLimitNOFILE=1000000\nLimitNPROC=16384\nTasksMax=100000\n\n# Memory limits\nMemoryLimit=8G\nMemoryHigh=7G\n\n# CPU limits (80% of 12 cores = ~10 cores)\nCPUQuota=1000%\n\n# Process priority\nNice=-5\nIOSchedulingClass=best-effort\nIOSchedulingPriority=0\n\n# Logging\nStandardOutput=journal\nStandardError=journal\nSyslogIdentifier=proxy-checker\n\n# Graceful shutdown\nKillMode=mixed\nKillSignal=SIGTERM\nTimeoutStopSec=30s\n\n# Watchdog (requires application support)\nWatchdogSec=60s\n\n[Install]\nWantedBy=multi-user.target\nAlias=proxychecker.service\n\n# Installation Instructions:\n# \n# 1. Create system user:\n#    sudo useradd -r -s /bin/false -d /opt/proxy-checker proxy-checker\n# \n# 2. Install binary:\n#    sudo cp proxy-checker /usr/local/bin/\n#    sudo chown root:root /usr/local/bin/proxy-checker\n#    sudo chmod 755 /usr/local/bin/proxy-checker\n#    sudo setcap 'cap_net_raw,cap_net_admin=+ep' /usr/local/bin/proxy-checker\n# \n# 3. Create directories:\n#    sudo mkdir -p /etc/proxy-checker /data /var/log/proxy-checker\n#    sudo chown proxy-checker:proxy-checker /data /var/log/proxy-checker\n#    sudo chmod 755 /etc/proxy-checker\n# \n# 4. Copy config:\n#    sudo cp config.json /etc/proxy-checker/\n#    sudo chmod 644 /etc/proxy-checker/config.json\n# \n# 5. Set API key:\n#    echo \"your-secret-key\" | sudo tee /etc/proxy-checker/api-key.txt\n#    sudo chmod 600 /etc/proxy-checker/api-key.txt\n#    sudo chown proxy-checker:proxy-checker /etc/proxy-checker/api-key.txt\n# \n# 6. Download blacklist:\n#    sudo wget -O /etc/proxy-checker/blacklist.txt \\\n#      https://raw.githubusercontent.com/zmap/zmap/master/conf/blacklist.conf\n# \n# 7. Install service:\n#    sudo cp proxy-checker.service /etc/systemd/system/\n#    sudo systemctl daemon-reload\n#    sudo systemctl enable proxy-checker\n#    sudo systemctl start proxy-checker\n# \n# 8. Verify:\n#    sudo systemctl status proxy-checker\n#    sudo journalctl -u proxy-checker -f\n#    curl -H \"X-Api-Key: your-secret-key\" http://localhost:8083/health\n# \n# 9. Check capabilities:\n#    getcap /usr/local/bin/proxy-checker\n#    # Should show: cap_net_admin,cap_net_raw=ep\n# \n# 10. Test zmap:\n#    sudo -u proxy-checker zmap -p 8080 -r 100 127.0.0.0/24\n#    # Should output IPs without permission errors\n\n# Troubleshooting:\n# \n# Error: \"Operation not permitted\" from zmap\n# Solution: Verify capabilities with getcap, re-run setcap command\n# \n# Error: Service fails to start\n# Solution: Check logs with journalctl -u proxy-checker -n 50\n# \n# Error: \"Permission denied\" for config file\n# Solution: Check file ownership and permissions in /etc/proxy-checker\n# \n# Performance: High CPU usage\n# Solution: Reduce checker.concurrency_total or zmap.rate_limit\n# \n# Performance: OOM killed\n# Solution: Increase MemoryLimit or reduce concurrency",
  
  "test_plan": "**Comprehensive Testing Plan for Zmap Integration**\n\n## 1. Unit Tests (tests/unit/)\n\n### 1.1 Config Tests (config_test.go)\n```go\nfunc TestZmapConfigDefaults(t *testing.T)\n  - Verify default values applied when fields missing\n  - Test enabled=false by default\n  \nfunc TestZmapConfigValidation(t *testing.T)\n  - Invalid port numbers (0, 70000)\n  - Invalid rate_limit (negative, > 1M)\n  - Invalid CIDR syntax in target_ranges\n  - Missing zmap_binary path\n  \nfunc TestFastFilterConfig(t *testing.T)\n  - Defaults applied correctly\n  - Validation of timeout and concurrency\n```\n\n### 1.2 Zmap Scanner Tests (internal/zmap/scanner_test.go)\n```go\nfunc TestParseZmapCSV(t *testing.T)\n  - Parse valid CSV with saddr,sport,timestamp\n  - Handle malformed lines gracefully\n  - Deduplicate repeated IPs\n  - Handle empty files\n  - Test data: testdata/zmap_output.csv\n  \nfunc TestParseZmapJSON(t *testing.T)\n  - Parse JSON output format\n  - Extract saddr field\n  \nfunc TestBuildZmapCmd(t *testing.T)\n  - Verify command arguments:\n    -p <port>\n    -r <rate>\n    -o <output>\n    --output-fields=saddr,sport,timestamp-str\n    -T <timeout>\n    -b <blacklist>\n  - Verify target ranges appended\n  - Verify extra args included\n  \nfunc TestDeduplication(t *testing.T)\n  - Input: [\"1.1.1.1:80\", \"1.1.1.1:80\", \"2.2.2.2:80\"]\n  - Output: [\"1.1.1.1:80\", \"2.2.2.2:80\"]\n  \nfunc TestOutputFileParsing(t *testing.T)\n  - Create temp file with mock CSV\n  - Parse and verify proxy list\n  - Clean up temp file\n```\n\n### 1.3 Capability Tests (internal/zmap/capabilities_test.go)\n```go\nfunc TestCheckCapabilities(t *testing.T)\n  - Mock capability checks\n  - Test root user detection (os.Geteuid() == 0)\n  - Test CAP_NET_RAW detection\n  \nfunc TestCheckZmapBinary(t *testing.T)\n  - Test with valid zmap path\n  - Test with missing binary\n  - Test version parsing\n```\n\n### 1.4 Safety Tests (internal/zmap/safety_test.go)\n```go\nfunc TestLoadBlacklist(t *testing.T)\n  - Parse blacklist.txt with CIDRs\n  - Verify default ranges included\n  - Handle missing file gracefully\n  \nfunc TestValidateTargets(t *testing.T)\n  - Reject .mil, .gov domains\n  - Warn on large ranges (0.0.0.0/0)\n  - Accept valid CIDR lists\n```\n\n### 1.5 Fast Filter Tests (internal/checker/fastfilter_test.go)\n```go\nfunc TestFastConnectFilter(t *testing.T)\n  - Start mock TCP server on localhost:8080\n  - Input: [\"127.0.0.1:8080\", \"127.0.0.1:9999\"]\n  - Output: [\"127.0.0.1:8080\"] (only connectable)\n  - Verify timeout works (dead servers filtered quickly)\n  - Verify concurrency (monitor goroutine count)\n```\n\n## 2. Integration Tests (tests/integration/)\n\n### 2.1 Zmap Integration Test (zmap_test.go)\n```go\nfunc TestZmapFullCycle(t *testing.T)\n  - Skip if RUN_ZMAP_TESTS != \"1\"\n  - Skip if not root/no capabilities\n  \n  Steps:\n  1. Start local HTTP server on port 8888\n  2. Configure zmap to scan 127.0.0.0/24 port 8888\n  3. Run scanner.Scan()\n  4. Verify output contains \"127.0.0.1:8888\"\n  5. Verify metrics recorded:\n     - zmap_scans_total{status=\"success\"} > 0\n     - zmap_candidates_found > 0\n  6. Stop server\n  \nfunc TestZmapTimeout(t *testing.T)\n  - Configure max_runtime_seconds = 5\n  - Start scan\n  - Verify scan terminates after ~5 seconds\n  - Verify context cancellation works\n  \nfunc TestZmapErrorHandling(t *testing.T)\n  - Configure invalid zmap path\n  - Verify error returned\n  - Configure invalid port (70000)\n  - Verify validation error\n```\n\n### 2.2 End-to-End Test (e2e_test.go)\n```go\nfunc TestE2EWithZmap(t *testing.T)\n  - Skip if not in CI environment\n  \n  Steps:\n  1. Load config with zmap enabled\n  2. Start full application\n  3. Wait for first aggregation cycle\n  4. Query /stats API\n  5. Verify proxies found from both sources:\n     - source_stats (scraped)\n     - zmap_stats (scanned)\n  6. Query /get-proxy?limit=10\n  7. Verify proxies returned\n  8. Trigger /reload with mode=zmap-only\n  9. Verify only zmap runs\n  10. Shutdown gracefully\n```\n\n### 2.3 API Integration (api_test.go)\n```go\nfunc TestReloadWithMode(t *testing.T)\n  - POST /reload {\"mode\": \"scrape-only\"}\n  - Verify only scraping happens\n  - POST /reload {\"mode\": \"zmap-only\"}\n  - Verify only zmap runs\n  - POST /reload {\"mode\": \"both\"}\n  - Verify both run\n  \nfunc TestZmapStatsEndpoint(t *testing.T)\n  - GET /stats/zmap\n  - Verify response:\n    {\n      \"enabled\": true,\n      \"ports\": [8080, 3128, 80],\n      \"last_scan_time\": \"2024-10-25T12:00:00Z\",\n      \"last_scan_duration\": 1234.5,\n      \"candidates_found\": 50000,\n      \"total_scans\": 42\n    }\n  - Test with zmap disabled\n  - Verify 404 or error message\n```\n\n## 3. Performance Tests (tests/perf/)\n\n### 3.1 Concurrency Test (concurrency_test.go)\n```go\nfunc TestHighConcurrencyChecking(t *testing.T)\n  - Generate 100k proxy candidates\n  - Configure concurrency_total = 20000\n  - Measure:\n    - Time to complete\n    - Peak goroutine count\n    - Peak memory usage\n    - Peak file descriptors\n  - Target: 3k-5k checks/sec\n  - Verify no goroutine leaks\n  \nfunc TestFastFilterPerformance(t *testing.T)\n  - 100k candidates\n  - Fast filter with 50k concurrency\n  - Measure filter time\n  - Target: <10 seconds\n  - Compare with no filter baseline\n```\n\n### 3.2 Zmap Performance (zmap_perf_test.go)\n```go\nfunc TestZmapRateLimit(t *testing.T)\n  - Configure rate_limit = 10000\n  - Scan 100k IPs (10 seconds expected)\n  - Measure actual duration\n  - Verify rate_limit honored (±10%)\n  \nfunc TestZmapMultiPort(t *testing.T)\n  - Scan ports [8080, 3128, 80]\n  - Measure total time\n  - Verify sequential execution\n  - Check candidates per port\n```\n\n### 3.3 Memory Profiling (memory_test.go)\n```go\nfunc TestMemoryUsage(t *testing.T)\n  - Run full cycle with 500k candidates\n  - Profile heap allocations\n  - Verify:\n    - Heap < 2GB\n    - No significant leaks\n    - GC pressure acceptable\n  - Generate pprof output\n```\n\n## 4. System Tests (scripts/)\n\n### 4.1 Smoke Test (scripts/zmap_smoke_test.sh)\n```bash\n#!/bin/bash\nset -e\n\necho \"Starting smoke test...\"\n\n# 1. Check binaries\nwhich zmap || { echo \"zmap not found\"; exit 1; }\nwhich proxy-checker || { echo \"proxy-checker not found\"; exit 1; }\n\n# 2. Check capabilities\ngetcap /usr/local/bin/zmap | grep -q \"cap_net_raw\" || { echo \"Missing capabilities\"; exit 1; }\n\n# 3. Start test HTTP server\npython3 -m http.server 8888 &\nSERVER_PID=$!\ntrap \"kill $SERVER_PID 2>/dev/null\" EXIT\nsleep 2\n\n# 4. Run zmap on localhost\necho \"Running zmap scan...\"\nsudo zmap -p 8888 -r 1000 -o /tmp/smoke_test.csv \\\n  --output-fields=saddr --output-module=csv 127.0.0.0/24\n\n# 5. Verify output\nif grep -q \"127.0.0.1\" /tmp/smoke_test.csv; then\n  echo \"✅ Zmap scan successful\"\nelse\n  echo \"❌ Zmap scan failed - no results\"\n  exit 1\nfi\n\n# 6. Test proxy-checker with zmap results\necho \"Testing proxy-checker...\"\ncat /tmp/smoke_test.csv | while read ip; do\n  echo \"$ip:8888\"\ndone > /tmp/proxies_test.txt\n\n# 7. Verify API responds\ncurl -sf http://localhost:8083/health || { echo \"API not responding\"; exit 1; }\n\necho \"✅ All smoke tests passed\"\n```\n\n### 4.2 Load Test (scripts/load_test.sh)\n```bash\n#!/bin/bash\n# Uses vegeta or ab to load test API\n# Concurrent requests to /get-proxy while zmap scan running\n# Measure:\n#   - Request latency (p50, p95, p99)\n#   - Error rate\n#   - Throughput (req/sec)\n# Target: <100ms p95, 0% errors, 100+ req/sec\n```\n\n## 5. Regression Tests\n\n### 5.1 Backward Compatibility (regression_test.go)\n```go\nfunc TestBackwardCompatibility(t *testing.T)\n  - Load config without zmap section\n  - Verify service starts normally\n  - Verify scraping still works\n  - Verify API endpoints unchanged\n  \nfunc TestZmapDisabled(t *testing.T)\n  - Load config with zmap.enabled = false\n  - Verify zmap scanner not initialized\n  - Verify no zmap scans run\n  - Verify performance unchanged from baseline\n```\n\n## 6. Security Tests\n\n### 6.1 Capability Tests (security_test.go)\n```go\nfunc TestNoRootRequired(t *testing.T)\n  - Drop to non-root user\n  - Verify capabilities sufficient\n  - Verify zmap still works\n  \nfunc TestBlacklistEnforced(t *testing.T)\n  - Configure target with private ranges\n  - Verify blacklist excludes them\n  - Verify .mil/.gov rejected\n```\n\n## 7. CI/CD Integration\n\n### 7.1 GitHub Actions Workflow (.github/workflows/test.yml)\n```yaml\nname: Test Zmap Integration\n\non: [push, pull_request]\n\njobs:\n  unit-tests:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - uses: actions/setup-go@v4\n        with:\n          go-version: '1.21'\n      - name: Install dependencies\n        run: |\n          sudo apt-get update\n          sudo apt-get install -y zmap libpcap-dev\n      - name: Run unit tests\n        run: go test -v ./internal/...\n        \n  integration-tests:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - uses: actions/setup-go@v4\n      - name: Install zmap\n        run: sudo apt-get install -y zmap\n      - name: Set capabilities\n        run: sudo setcap 'cap_net_raw,cap_net_admin=+ep' $(which zmap)\n      - name: Run integration tests\n        run: RUN_ZMAP_TESTS=1 sudo -E go test -v ./tests/integration/...\n        \n  smoke-test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - name: Build binary\n        run: go build -o proxy-checker ./cmd/main.go\n      - name: Run smoke test\n        run: sudo bash scripts/zmap_smoke_test.sh\n```\n\n## 8. Manual Test Checklist\n\n**Pre-deployment:**\n- [ ] Unit tests pass (100% coverage on new code)\n- [ ] Integration tests pass\n- [ ] Smoke test passes on staging\n- [ ] Load test meets performance targets\n- [ ] Security audit complete\n- [ ] Documentation updated\n- [ ] Legal review complete\n\n**Post-deployment:**\n- [ ] Monitor zmap_scans_total metric\n- [ ] Verify candidates_found > 0\n- [ ] Check logs for errors\n- [ ] Test API endpoints\n- [ ] Verify no complaints/abuse reports\n- [ ] Monitor resource usage (CPU, memory, network)\n- [ ] Validate proxy quality (alive %)\n\n## 9. Performance Benchmarks\n\n### Expected Results:\n| Metric | Target | Measured |\n|--------|--------|---------|\n| Zmap scan rate | 10k pps | ___ |\n| Zmap duration (3 ports) | <30 min | ___ |\n| Candidates found | 50k-200k | ___ |\n| Fast filter time | <15s | ___ |\n| Full check time | <60s | ___ |\n| Total cycle | <45 min | ___ |\n| Working proxies | 5k-10k | ___ |\n| Checks/sec | 3k-5k | ___ |\n| API latency p95 | <100ms | ___ |\n| Memory usage | <8GB | ___ |\n| CPU usage | <80% | ___ |\n\n## 10. Failure Scenarios\n\n- [ ] Zmap binary not found → Service starts, zmap disabled, warning logged\n- [ ] No capabilities → Service starts, zmap disabled, warning logged\n- [ ] Zmap scan fails → Error logged, metrics updated, retry next cycle\n- [ ] Zmap timeout → Partial results used, warning logged\n- [ ] No candidates found → Info logged, no error\n- [ ] All candidates dead → Stats show 0 alive, no crash\n- [ ] Config invalid → Validation error, service won't start\n- [ ] Network down → Zmap fails gracefully, scraping retries\n\n**Test Coverage Target: 85%+ overall, 95%+ on zmap module**",
  
  "legal_notes": "**Legal & Ethical Considerations for Network Scanning**\n\n⚠️ **IMPORTANT: READ BEFORE ENABLING ZMAP** ⚠️\n\n## Legal Warnings\n\nNetwork scanning without authorization may violate laws in many jurisdictions. **You are solely responsible for ensuring compliance with all applicable laws** in your region and the regions you scan.\n\n### Key Legal Frameworks\n\n**United States:**\n- **Computer Fraud and Abuse Act (CFAA), 18 U.S.C. § 1030**\n  - Prohibits unauthorized access to computer systems\n  - Scanning may be considered \"unauthorized access\" depending on interpretation\n  - Penalties: Criminal prosecution, civil liability, fines up to $250k, imprisonment up to 20 years\n  \n**European Union:**\n- **NIS Directive (2016/1148)** - Requires security for critical infrastructure\n- **GDPR (2016/679)** - Scanning may involve processing personal data (IP addresses)\n- **Network and Information Security (NIS2) Directive** - Enhanced security requirements\n- **Member state laws vary** - Germany's Criminal Code Section 202a-c particularly strict\n\n**United Kingdom:**\n- **Computer Misuse Act 1990**\n  - Section 1: Unauthorized access to computer material (up to 2 years)\n  - Section 2: Unauthorized access with intent (up to 5 years)\n  - Scanning without permission may violate Section 1\n\n**Other Jurisdictions:**\n- **Canada:** Criminal Code Section 342.1 (unauthorized use of computer)\n- **Australia:** Criminal Code Act 1995, Part 10.7\n- **China:** Cybersecurity Law (2017) - Extremely strict\n- **Russia:** Federal Law No. 187-FZ - Requires authorization\n- **Japan:** Unauthorized Computer Access Law (1999)\n\n## Best Practices for Legal Compliance\n\n### 1. Obtain Explicit Permission\n\n**✅ DO:**\n- Only scan networks you own or have **written authorization** to scan\n- Keep authorization letters on file for audit\n- Scan your own infrastructure for proxy detection\n- Use allow-lists (`target_ranges`) to limit scope\n- Obtain ASN-level permission from network owners\n\n**❌ DON'T:**\n- Scan the entire IPv4 space without permission\n- Scan government (.gov, .mil) or military networks\n- Scan critical infrastructure (healthcare, finance, utilities)\n- Scan educational institutions without IT department approval\n- Scan cloud providers (AWS, Azure, GCP) without violating ToS\n\n### 2. Implement Robust Allow-Lists\n\n**Configure target_ranges conservatively:**\n```json\n{\n  \"zmap\": {\n    \"target_ranges\": [\n      \"203.0.113.0/24\",        // Your own network\n      \"198.51.100.0/24\"        // Partner network (with permission)\n    ],\n    \"blacklist\": [\n      \"/etc/proxy-checker/blacklist.txt\",  // Standard blacklist\n      \"/etc/proxy-checker/custom_blacklist.txt\"  // Your additions\n    ]\n  }\n}\n```\n\n**Always exclude:**\n- Private IP ranges (RFC 1918): 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16\n- Loopback: 127.0.0.0/8\n- Link-local: 169.254.0.0/16\n- Multicast: 224.0.0.0/4\n- Reserved: 240.0.0.0/4\n- Government: .mil, .gov domains\n- Healthcare: HIPAA-covered entities\n- Finance: Banks, stock exchanges\n- Critical infrastructure: Power grids, water, transportation\n\n### 3. Rate Limiting & Good Netizen Behavior\n\n**Conservative scan parameters:**\n```json\n{\n  \"zmap\": {\n    \"rate_limit\": 5000,           // 5k pps (conservative)\n    \"bandwidth\": \"10M\",            // Limit bandwidth\n    \"max_runtime_seconds\": 1800,  // 30 min max\n    \"cooldown_seconds\": 3600      // 1 hour between scans\n  }\n}\n```\n\n**Rationale:**\n- Lower rates reduce network impact\n- Demonstrates non-malicious intent\n- Allows network operators to detect and respond\n- Reduces risk of triggering DoS protection\n\n### 4. Transparency & Opt-Out\n\n**Set up abuse contact:**\n```\nEmail: abuse@yourdomain.com\nPhone: +1-555-ABUSE (555-222-8737)\nResponse time: Within 24 hours\n```\n\n**Publish scanning policy:**\n- Create `yourdomain.com/scanning-policy.html`\n- Include:\n  - Purpose of scanning\n  - Opt-out instructions\n  - Data retention policy\n  - Contact information\n  - Compliance certifications\n\n**Reverse DNS (PTR) record:**\n```\n; Set PTR record for scanning IPs\n1.0.0.203.in-addr.arpa.  IN  PTR  scanner.yourdomain.com.\n```\n\n**User-Agent / Banner:**\n```go\nconst UserAgent = \"ProxyChecker/2.0 (+https://yourdomain.com/scanning-policy.html)\"\n```\n\n### 5. Honor Opt-Out Requests\n\n**Maintain opt-out list:**\n```bash\n# /etc/proxy-checker/optout.txt\n192.0.2.0/24      # Requested 2024-10-01 via abuse@\n198.51.100.15/32  # Requested 2024-10-02 via legal@\n```\n\n**Process within 24 hours:**\n1. Receive opt-out request\n2. Add to blacklist immediately\n3. Confirm via email\n4. Log in audit trail\n5. Retain for compliance\n\n### 6. Audit Logging\n\n**Log all scans:**\n```json\n{\n  \"timestamp\": \"2024-10-25T12:00:00Z\",\n  \"scan_id\": \"scan_12345\",\n  \"ports\": [8080, 3128, 80],\n  \"target_ranges\": [\"203.0.113.0/24\"],\n  \"rate_limit\": 10000,\n  \"duration_seconds\": 1234,\n  \"candidates_found\": 50000,\n  \"operator\": \"admin@yourdomain.com\"\n}\n```\n\n**Retain logs:**\n- Minimum 1 year\n- Accessible for legal requests\n- Demonstrate good faith\n\n### 7. Data Protection (GDPR/Privacy)\n\n**IP addresses = personal data:**\n- Under GDPR, IP addresses are personal data\n- Requires legal basis (legitimate interest)\n- Must allow data subject access requests (DSAR)\n- Implement retention limits\n\n**Recommended practices:**\n- Don't store IP addresses longer than necessary\n- Anonymize or aggregate where possible\n- Provide privacy policy\n- Honor deletion requests\n- Implement data minimization\n\n### 8. Terms of Service Compliance\n\n**Check ToS of hosting providers:**\n- **AWS:** Penetration testing requires approval ([aws.amazon.com/security/penetration-testing](https://aws.amazon.com/security/penetration-testing/))\n- **Azure:** Similar restrictions\n- **GCP:** Scanning allowed within your own projects only\n- **DigitalOcean:** Network scanning prohibited without permission\n- **Hetzner:** Scanning may trigger abuse warnings\n- **OVH:** Requires notification\n\n**Your scanning server:**\n- Verify your hosting provider allows outbound scanning\n- Notify provider of scanning activity\n- Maintain abuse contact responsiveness\n- Consider dedicated \"security research\" hosting (e.g., pfcloud.io, BuyVM)\n\n### 9. Academic / Research Exemptions\n\n**Some jurisdictions recognize research exemptions:**\n- Must be for legitimate research purposes\n- Published in peer-reviewed venues\n- Follow ethical guidelines (IRB approval)\n- Minimize harm\n- Disclose findings responsibly\n\n**Example: Internet-Wide Scanning Studies**\n- ZMap research team publishes findings\n- Censys, Shodan operate under research frameworks\n- Follow best practices: [scans.io](https://scans.io), [Censored Planet](https://censoredplanet.org)\n\n### 10. Liability Mitigation\n\n**Implement technical safeguards:**\n- ✅ Mandatory blacklists (no opt-out)\n- ✅ Rate limiting (hard limits)\n- ✅ Audit logging (immutable)\n- ✅ Opt-out mechanism (automated)\n- ✅ Abuse contact (monitored 24/7)\n\n**Legal safeguards:**\n- 📄 Maintain written authorization for all target ranges\n- 📄 Publish terms of service / acceptable use policy\n- 📄 Cyber liability insurance ($1M+ recommended)\n- 📄 Consult legal counsel in your jurisdiction\n- 📄 Consider forming LLC/corporation to limit personal liability\n\n**Incident response plan:**\n1. Abuse complaint received\n2. Immediately cease scanning complained IP\n3. Add to permanent blacklist\n4. Respond to complainant within 4 hours\n5. Investigate root cause\n6. Update procedures if needed\n7. Log in incident database\n\n### 11. Recommended Configuration for Legal Safety\n\n```json\n{\n  \"zmap\": {\n    \"enabled\": false,  // KEEP DISABLED unless legally cleared\n    \"rate_limit\": 5000,  // Conservative 5k pps\n    \"max_runtime_seconds\": 1800,  // 30 min max\n    \"cooldown_seconds\": 7200,  // 2 hours between scans\n    \"target_ranges\": [\n      // ONLY YOUR OWNED/AUTHORIZED NETWORKS\n    ],\n    \"blacklist\": [\n      \"/etc/proxy-checker/blacklist.txt\",  // Standard\n      \"/etc/proxy-checker/optout.txt\"      // Opt-outs\n    ]\n  },\n  \"checker\": {\n    \"user_agent\": \"ProxyChecker/2.0 (+https://yourdomain.com/policy.html; abuse@yourdomain.com)\"\n  }\n}\n```\n\n## Resources\n\n**Legal Research:**\n- [EFF: Coders' Rights Project](https://www.eff.org/issues/coders)\n- [CFAA Reform](https://www.eff.org/issues/cfaa)\n- [ZMap Ethics & Legality](https://github.com/zmap/zmap/wiki/Scanning-Best-Practices)\n- [Shodan Scanning Policy](https://help.shodan.io/the-basics/what-is-shodan)\n\n**Technical Best Practices:**\n- [Zmap Best Practices](https://github.com/zmap/zmap/wiki/Scanning-Best-Practices)\n- [Censys Scanning Methodology](https://about.censys.io/methodology/)\n- [OPSEC for Security Researchers](https://github.com/veeral-patel/how-to-secure-anything)\n\n**Standards:**\n- [NIST SP 800-115: Technical Guide to Information Security Testing](https://csrc.nist.gov/publications/detail/sp/800-115/final)\n- [OWASP Testing Guide](https://owasp.org/www-project-web-security-testing-guide/)\n\n## Disclaimer\n\n**This document is for educational purposes only and does not constitute legal advice.** Laws vary by jurisdiction and change over time. Consult a qualified attorney licensed in your jurisdiction before conducting network scanning activities. The authors and contributors disclaim all liability for any legal consequences resulting from use of this software.\n\n**By enabling zmap scanning, you acknowledge:**\n1. You have read and understood the legal risks\n2. You have obtained necessary permissions/authorizations\n3. You will comply with all applicable laws\n4. You accept full responsibility for your scanning activities\n5. You will not hold the software authors/contributors liable\n\n**When in doubt, DON'T scan.** Stick to scraping public proxy lists, which is generally legal and lower-risk."
}

